---
title: Unix下的I/O模型
date: 2018-08-26 22:42:23
tags:
---
## 什么是I/O多路复用
进程需要一个预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好呗读取，或者描述符已经能承接更多的输出），它就通知进程，这个能力称为I/O复用（I/O multiplexing)
## I/O复用典型使用 场合
* 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用。这是我们 早先讲述过的场合。
* 一个客户同事处理多个套接字是可能的，不过比较少见。
* 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用I/O复用。
* 如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用。
* 如果一个服务器 要处理多个服务或者多个协议，一般就要使用I/O复用。
## UNIX下五种 I/O 模型
* 阻塞式I/O;
* 非阻塞式I/O;
* I/O复用（select和poll）
* 信号驱动式I/O（SIGIO);
* 异步I/O（POSIX的aio）
>  一个输入 操作通常包括两个不同的阶段；
> 1. 等到数据准备好；
> 2. 从 内核向进程复制数据。
>  对于一个套接字上的输入操作，第一步通常 设计等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二部就是把数据从内核缓冲区复制到应用进程缓冲区。
###  阻塞时I/O模型
![](./_image/2018-08-26-21-20-54.png)
进程在从调用recvform开始到它返回的整段时间是被阻塞的。recvform成功返回后，应用进程开始处理数据报
### 非阻塞式I/O模型 
    进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。我们将在第16章中详细介绍非阻塞式I/O（nonblocking I/O）
![](./_image/2018-08-26-21-44-32.png)

    前三次调用recvfrom时没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。 第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom 成功返回。我们接着处理数据。
    当一个应用进程像这样对一个非阻塞描述符循环调用 recvfrom 时， 我们称之为轮询 （polling）。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间， 不过这种模型偶尔也会遇到，通常是在专门提供某一种功能的系统中才有。
### I/O复用模型
    有了I/O复用（I/O multiplexing），我们就可以调用select或poll，阻塞在这两个系统调用 中的某一个之上，而不是阻塞在真正的I/O系统调用上
![](./_image/2018-08-26-21-45-30.png)
    我们阻塞于select调用 ，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvform把所读数据报复制到应用进程缓冲区。
>  使用select的优势在于我们 可以等待多个描述符就绪，与I/O复用密切相关的另一种I/O模型是在多线程中使用阻塞
> 式I/O。这种模型与上述模型 极为相似，但它没有使用select阻塞在多个文件描述符上，而是使用多个线程（每个文件描述符一个线程），这样每个线程都可以自由地调用诸如recvfrom之类的阻塞式I/O系统调 用了。
### 信号驱动式I/O模型
    我们也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们。我们称这个模型为信号驱动式 I/O（signal-driven I/O)
![](https://ibb.co/i2yYyUg)
        我们首先开启套接字的信号驱动式I/O功能，并通过 sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作， 也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们 随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理 ，也可以立即通知主循环，让它读取数据报。
    无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取
### 异步I/O模型
    异步I/O（asynchronous）由POSIX规范定义，演变成当前POSIX规范的各种早期标准所定义的实时函数中存在的差异已经取得一致。一般地说，这些函数的工作机制是：告知内核启 动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知 我们。这种模型与信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我 们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成
![](./_image/2018-08-26-22-00-56.png)

### 各种I/O对比
* 同步I/O操作（synchronous I/O operation）导致请求进程阻塞，直到I/O操作完成；
* 异步I/O操作（asynchronous I/O operation）不导致请求进程阻塞
![](./_image/2018-08-26-22-07-36.png)






